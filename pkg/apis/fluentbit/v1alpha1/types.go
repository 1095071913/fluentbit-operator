package v1alpha1

import (
	"encoding/json"
	"fmt"
	"github.com/operator-framework/operator-sdk/pkg/sdk"
	"github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// FluentBitOperatorList auto generated by the sdk
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type FluentBitOperatorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata"`
	Items           []FluentBitOperator `json:"items"`
}

// FluentBitOperator auto generated by the sdk
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type FluentBitOperator struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata"`
	Spec              FluentBitOperatorSpec   `json:"spec"`
	Status            FluentBitOperatorStatus `json:"status,omitempty"`
}

// FluentBitOperatorSpec holds the spec for the operator
type FluentBitOperatorSpec struct {
	Service  []Plugin `json:"service"`
	Input    []Plugin `json:"input"`
	Filter   []Plugin `json:"filter"`
	Output   []Plugin `json:"output"`
	Settings []Plugin `json:"settings"`
}

// FluentBitOperatorStatus holds the status info for the operator
type FluentBitOperatorStatus struct {
	// Fill me
}

// Plugin struct for fluent-bit plugins
type Plugin struct {
	Type       string      `json:"type"`
	Name       string      `json:"name"`
	Parameters []Parameter `json:"parameters"`
}

// RenderPlugin general Plugin renderer
func RenderPlugin(plugin Plugin, baseMap map[string]string, namespace string, configprefix string) (string, error) {
	var config string

	config = configprefix + "\n"

	for _, param := range plugin.Parameters {
		k, v := param.GetValue(namespace)
		config = config + "    " + k + "     " + v + "\n"
	}

	return config, nil
}

func ProcessSettings(plugin Plugin, settings map[string]string, baseMap map[string]string, namespace string) {
	for _, param := range plugin.Parameters {
		k, v := param.GetValue(namespace)
		settings[k] = v
	}
}

func RenderSettings(settings map[string]string) (string, error) {
	jsonSettings, err := json.Marshal(settings)
	if err != nil {
		fmt.Println("json.Marshal failed:", err)
		return "", err
	}

	return string(jsonSettings), nil
}

// Parameter generic parameter type to handle values from different sources
type Parameter struct {
	Name      string     `json:"name"`
	ValueFrom *ValueFrom `json:"valueFrom"`
	Value     string     `json:"value"`
}

// GetValue for a Parameter
func (p Parameter) GetValue(namespace string) (string, string) {
	if p.ValueFrom != nil {
		value, error := p.ValueFrom.GetValue(namespace)
		if error != nil {
			logrus.Error(error)
			return "", ""
		}
		return p.Name, value
	}
	return p.Name, p.Value
}

// ValueFrom generic type to determine value origin
type ValueFrom struct {
	SecretKeyRef KubernetesSecret `json:"secretKeyRef"`
}

// GetValue handles the different origin of ValueFrom
func (vf *ValueFrom) GetValue(namespace string) (string, error) {
	return vf.SecretKeyRef.GetValue(namespace)
}

// KubernetesSecret is a ValueFrom type
type KubernetesSecret struct {
	Name      string `json:"name"`
	Key       string `json:"key"`
	Namespace string `json:"namespace"`
}

// GetValue implement GetValue interface
func (ks KubernetesSecret) GetValue(namespace string) (string, error) {
	secret := corev1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Namespace: namespace,
			Name:      ks.Name,
		},
	}
	if ks.Namespace != "" {
		secret.ObjectMeta.Namespace = ks.Namespace
	}
	err := sdk.Get(&secret)
	if err != nil {
		return "", err
	}
	value, ok := secret.Data[ks.Key]
	if !ok {
		return "", fmt.Errorf("key %q not found in secret %q in namespace %q", ks.Key, secret.ObjectMeta.Name, secret.ObjectMeta.Namespace)
	}
	return string(value), nil
}
